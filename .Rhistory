<<<<<<< HEAD
# Brainstorm Project
library(lint)
Group members: Katie Pryal, Sydney Burns, Nate Getz, Sabrina Ebengho
# Brainstorm Project
library(lintr)
Group members: Katie Pryal, Sydney Burns, Nate Getz, Sabrina Ebengho
library(lintr)
lint("assignment.r")
lint("READ.md")
=======
install.packages(ggplot2)
install.packages("ggplot2")
library(ggplot2)
library(dplyr)
# For this exercise you'll be working with the `diamonds` data set included in
# the ggplot2 library
# Use `?diamonds` to get more information about this data set (including the
# column descriptions. Also check the _column names_ and the _number of rows_
# in the data set
?diamonds
nrow(diamomds)
nrow(diamonds)
# This data set has A LOT of rows. To make things a bit more readable,
# use dplyr's `sample_n()` function to get a random 1000 rows from the data set
# Store this sample in a variable `diamonds_sample`
sample_n(diamonds, 1000)
# This data set has A LOT of rows. To make things a bit more readable,
# use dplyr's `sample_n()` function to get a random 1000 rows from the data set
# Store this sample in a variable `diamonds_sample`
diamond_sample <- sample_n(diamonds, 1000)
View(diamond_sample)
# Start by making a new `ggplot` with the `diamonds_sample` as the data (no
# geometry yet)
# What do you see? (What did you expect?)
ggplot(diamond_sample)
# Start by making a new `ggplot` with the `diamonds_sample` as the data (no
# geometry yet)
# What do you see? (What did you expect?)
ggplot(data = diamond_sample)
# Draw a scatter plot (with point geometry) with for the `diamonds_sample` set,
# with the `carat` mapped to the x-position and `price` mapped to the y-position.
ggplot(data = diamond_sample) +
geom_point(mapping = aes(x = carat, y = price))
# Draw the same plot as above, but color each of the points based on their
# clarity.
ggplot(data = diamond_sample) +
geom_point(mapping = aes(x = carat, y = price, color = clarity))
# Draw the same plot as above, but for the entire `diamonds` data set. Note this
# may take a few seconds to generate.
ggplot(data = diamond) +
geom_point(mapping = aes(x = carat, y = price, color = clarity))
# Draw the same plot as above, but for the entire `diamonds` data set. Note this
# may take a few seconds to generate.
ggplot(data = diamonds) +
geom_point(mapping = aes(x = carat, y = price, color = clarity))
# Draw another scatter plot for `diamonds_sample` of price (y) by carat (x),
# but with all of the dots colored "blue".
# Hint: you'll need to set the color channel, not map a value to it!
ggplot(data = diamond_sample) +
geom_point(mapping = aes(x = carat, y = price, color = blue)) +
color
# Draw another scatter plot for `diamonds_sample` of price (y) by carat (x),
# but with all of the dots colored "blue".
# Hint: you'll need to set the color channel, not map a value to it!
ggplot(data = diamond_sample) +
geom_point(mapping = aes(x = carat, y = price)) +
geom_point(color='blue')
# Draw another scatter plot for `diamonds_sample` of price (y) by carat (x),
# but with all of the dots colored "blue".
# Hint: you'll need to set the color channel, not map a value to it!
ggplot(data = diamond_sample) +
geom_point(mapping = aes(x = carat, y = price)) +
geom_point(color = "blue")
# Draw another scatter plot for `diamonds_sample` of price (y) by carat (x),
# but with all of the dots colored "blue".
# Hint: you'll need to set the color channel, not map a value to it!
ggplot(data = diamond_sample) +
geom_point(mapping = aes(x = carat, y = price), color="blue")
# Draw a scatter plot for `diamonds_sample` of `price` by `carat`, where each
# point has an aesthetic _shape_ based on the diamond's `cut`.
ggplot(data = diamonds) +
geom_point(mapping = aes(x = carat, y = price, shape = cut))
# Draw a scatter plot for `diamonds_sample` of `price` by `carat`, where each
# point has an aesthetic _shape_ based on the diamond's `cut`.
ggplot(data = diamond_sample) +
geom_point(mapping = aes(x = carat, y = price, shape = cut))
# Draw a scatter plot for `diamonds_sample` of *`cut`* by `carat`, where each
# point has an aesthetic _size_ based on the diamond's *`price`*
ggplot(data = diamond_sample) +
geom_point(mapping = aes(x = cut, y = carat, size = price))
# Try coloring the above plot based on the diamond's price!
ggplot(data = diamond_sample) +
geom_point(mapping = aes(x = cut, y = carat, size = price, colot = price))
# Try coloring the above plot based on the diamond's price!
ggplot(data = diamond_sample) +
geom_point(mapping = aes(x = cut, y = carat, size = price, color = price))
# Draw a line plot (with line geometry) for `diamonds_sample`. The x-position
# should be mapped to carat, y-position to price, and color to cut.
ggplot(data = diamond_sample) +
geom_line(mapping = aes(x = carat, y = price, color = cut))
# That's kind of messy. Try using `smooth` geometry instead.
ggplot(data = diamond_sample) +
geom_smooth(mapping = aes(x = carat, y = price, color = cut))
# Draw a plot with column geometry (a bar chart), mapping the diamond's `cut` to
# the x-axis and `price` to the y-axis. Note that by default, column geometry
# will us the "sum" of all of the y-values, so that the chart is actually of the
# TOTAL value of all of the diamonds of that cut!
ggplot(data = diamond_sample) +
geom_bar(mapping = aes(x = cut, y = price))
# Draw a plot with column geometry (a bar chart), mapping the diamond's `cut` to
# the x-axis and `price` to the y-axis. Note that by default, column geometry
# will us the "sum" of all of the y-values, so that the chart is actually of the
# TOTAL value of all of the diamonds of that cut!
ggplot(data = diamond_sample) +
geom_bar(mapping = aes(x = cut, y = price))
# Draw a plot with column geometry (a bar chart), mapping the diamond's `cut` to
# the x-axis and `price` to the y-axis. Note that by default, column geometry
# will us the "sum" of all of the y-values, so that the chart is actually of the
# TOTAL value of all of the diamonds of that cut!
ggplot(data = diamond_sample) +
geom_bar(mapping = aes(x = cut, fill = price))
# Draw a plot with column geometry (a bar chart), mapping the diamond's `cut` to
# the x-axis and `price` to the y-axis. Note that by default, column geometry
# will us the "sum" of all of the y-values, so that the chart is actually of the
# TOTAL value of all of the diamonds of that cut!
ggplot(data = diamond_sample) +
geom_column(mapping = aes(x = cut, x = price))
ggplot(data = diamond_sample) +
geom_bar(mapping = aes(x = cut, fill = price, color = clarity))
# Draw a plot with column geometry (a bar chart), mapping the diamond's `cut` to
# the x-axis and `price` to the y-axis. Note that by default, column geometry
# will us the "sum" of all of the y-values, so that the chart is actually of the
# TOTAL value of all of the diamonds of that cut!
ggplot(data = diamond_sample) +
geom_bar(mapping = aes(x = cut, fill = price))
= price))
# Draw a line plot (with line geometry) for `diamonds_sample`. The x-position
# should be mapped to carat, y-position to price, and color to cut.
ggplot(data = diamond_sample) +
# That's kind of messy. Try using `smooth` geometry instead.
ggplot(data = diamond_sample) +
geom_smooth(mapping = aes(x = carat, y = price, color = cut))
# Draw a line plot (with line geometry) for `diamonds_sample`. The x-position
# should be mapped to carat, y-position to price, and color to cut.
ggplot(data = diamond_sample) +
geom_line(mapping = aes(x = carat, y = price, color = cut))
# That's kind of messy. Try using `smooth` geometry instead.
ggplot(data = diamond_sample) +
geom_smooth(mapping = aes(x = carat, y = price, color = cut))
# Install and load the `ggplot2` package
#install.packages('ggplot2')
library("ggplot2")
# Draw a column (bar) chart of diamonds cuts by price, with each bar filled by
# clarity. You should see a _stacked_ bar chart.
ggplot(data = diamond_sample) +
geom_bar(mapping = aes(x = price, y = price, fill = clarity))
# Install and load the `ggplot2` package
#install.packages('ggplot2')
library("ggplot2")
# Draw a column (bar) chart of diamonds cuts by price, with each bar filled by
# clarity. You should see a _stacked_ bar chart.
ggplot(data = diamond_sample) +
geom_bar(mapping = aes(x = price, y = price, fill = clarity))
# Draw a column (bar) chart of diamonds cuts by price, with each bar filled by
# clarity. You should see a _stacked_ bar chart.
ggplot(data = diamond_sample) +
geom_bar(mapping = aes(x = price, y = cut, fill = clarity))
# Draw a column (bar) chart of diamonds cuts by price, with each bar filled by
# clarity. You should see a _stacked_ bar chart.
ggplot(data = diamond_sample) +
geom_bar(mapping = aes(x = price, fill = clarity))
# Draw the same chart again, but with each element positioned to "fill" the y axis
ggplot(data = diamond_sample) +
geom_bar(mapping = aes(x = price, fill = clarity)) +
coord_flip()
# Draw the same chart again, but with each element positioned to "dodge" each other
ggplot(data = diamond_sample) +
geom_bar(mapping = aes(x = price, fill = clarity)) +
coord_flip() +
position_dodge(width = NULL, preserve = c("total", "single"))
# Draw the same chart again, but with each element positioned to "dodge" each other
ggplot(data = diamond_sample) +
geom_bar(mapping = aes(x = price, fill = clarity)) +
coord_flip() +
position_dodge()
# Draw the same chart again, but with each element positioned to "dodge" each other
ggplot(data = diamond_sample) +
geom_bar(mapping = aes(x = price, fill = clarity)) +
coord_flip() +
position_dodge2(
width = NULL,
preserve = c("total", "single"),
padding = 0.1,
reverse = FALSE
)
# Draw the same chart again, but with each element positioned to "dodge" each other
ggplot(data = diamond_sample) +
geom_bar(mapping = aes(x = price, fill = clarity)) +
coord_flip() +
position_dodge2(
width = NULL
)
# Draw the same chart again, but with each element positioned to "dodge" each other
ggplot(data = diamond_sample) +
geom_bar(mapping = aes(x = price, fill = clarity), position ="dodge") +
coord_flip()
# Load necessary packages (`dplyr`, `ggplot2`, and `plotly`)
library(dplyr)
library(ggplot2)
libary(plotly)
library(ggplot2)
library(plotly)
setwd("~/Documents/infoGit/exercises-K42IE/chapter-17-exercises/exercise-1")
# This is actually a very large and rich dataset, but we will only focus on
# a small subset of it. Create a new data frame `plot_data` by filtering the
# `mortality_rates` data to the following:
# - The `location_name` is "King County"
# - The `sex` is *not* "Both"
# - The `cause_name` is "Neoplasms"
# - The `year_id` is greater than 2004
# - Only keep the columns `sex`, `year_id`, and `mortality_rate`
plot_data <- mortality_rates %>%
filter(location_name == "King County", cause_name == "Neoplasms", year_id > 2004)
library(dplyr)
library(ggplot2)
library(plotly)
# This is actually a very large and rich dataset, but we will only focus on
# a small subset of it. Create a new data frame `plot_data` by filtering the
# `mortality_rates` data to the following:
# - The `location_name` is "King County"
# - The `sex` is *not* "Both"
# - The `cause_name` is "Neoplasms"
# - The `year_id` is greater than 2004
# - Only keep the columns `sex`, `year_id`, and `mortality_rate`
plot_data <- mortality_rates %>%
filter(location_name == "King County", cause_name == "Neoplasms", year_id > 2004)
mortality_rates
# Load the `"data/IHME_WASHINGTON_MORTALITY_RATES_1980_2014.csv` file
# into a variable `mortality_rates`
# Make sure strings are *not* read in as factors
mortality_rates <- read.csv("data/IHME_WASHINGTON_MORTALITY_RATES_1980_2014.csv", stringsAsFactors = FALSE)
# This is actually a very large and rich dataset, but we will only focus on
# a small subset of it. Create a new data frame `plot_data` by filtering the
# `mortality_rates` data to the following:
# - The `location_name` is "King County"
# - The `sex` is *not* "Both"
# - The `cause_name` is "Neoplasms"
# - The `year_id` is greater than 2004
# - Only keep the columns `sex`, `year_id`, and `mortality_rate`
plot_data <- mortality_rates %>%
filter(location_name == "King County", cause_name == "Neoplasms", year_id > 2004)
View(plot_data)
# This is actually a very large and rich dataset, but we will only focus on
# a small subset of it. Create a new data frame `plot_data` by filtering the
# `mortality_rates` data to the following:
# - The `location_name` is "King County"
# - The `sex` is *not* "Both"
# - The `cause_name` is "Neoplasms"
# - The `year_id` is greater than 2004
# - Only keep the columns `sex`, `year_id`, and `mortality_rate`
plot_data <- mortality_rates %>%
filter(location_name == "King County", cause_name == "Neoplasms", year_id > 2004) %>%
select(ex, year_id, mortality_rate)
View(plot_data)
# This is actually a very large and rich dataset, but we will only focus on
# a small subset of it. Create a new data frame `plot_data` by filtering the
# `mortality_rates` data to the following:
# - The `location_name` is "King County"
# - The `sex` is *not* "Both"
# - The `cause_name` is "Neoplasms"
# - The `year_id` is greater than 2004
# - Only keep the columns `sex`, `year_id`, and `mortality_rate`
plot_data <- mortality_rates %>%
filter(location_name == "King County", cause_name == "Neoplasms", year_id > 2004) %>%
select(sex, year_id, mortality_rate)
# Using ggplot2 (recall chapter 16), make a grouped ("dodge") bar chart of
# mortality rates each year, with different bars for each sex.
# Store this plot in a variable `mort_plot`
mort_plot <- ggplot(plot_data, aes(fill=sex, y=year_id, x=mortality_rate)) +
geom_bar(position="dodge", stat="identity")
mort_plot
# To make this plot interactive, pass `mort_plot` to the `ggplotly()` function
# (which is part of the `plotly` package). This will make your plot interactive!
ggplotly(mort_plot)
# Using the `plot_ly()` function from the `plotly` package, pass in `plot_data`
# as the data, and specify `year_id` as the x variable, mortality_rate as
# the y variable, and `sex` as the color variable.
# (make sure to specify these as *formulas*)
# Also set the plot type to "bar". Store the result in a variable.
plot_ly(plot_data, x = year_id, y = mortality_rate, color = `sex`)
# Using the `plot_ly()` function from the `plotly` package, pass in `plot_data`
# as the data, and specify `year_id` as the x variable, mortality_rate as
# the y variable, and `sex` as the color variable.
# (make sure to specify these as *formulas*)
# Also set the plot type to "bar". Store the result in a variable.
plot_ly(plot_data, x = ~year_id, y = ~mortality_rate, color = ~sex)
# You should see that the cancer mortaility rates for female and males
# each year are plotted next to each other.
# Now that we have the foundation down, we can make our plot more presentable
# by adding a layout to the plot. Add a title for the overall plot, and
# a title for each axes.
plot_ly(plot_data, x = ~year_id, y = ~mortality_rate, color = ~sex) %>%
layout(
title = "Title"
)
install.packages(leaflet)
install.packages("leaflet")
library(leatlet)
library(leaflet)
setwd("~/Documents/infoGit/exercises-K42IE/chapter-17-exercises/exercise-3")
# Load the `"data/uscitiesv1.4.csv` file into a variable `populations`
# Make sure strings are *not* read in as factors
populations <- read.csv("data/uscitiesv1.4.csv", stringsAsFactors = FALSE)
# Load the `"data/uscitiesv1.4.csv` file into a variable `populations`
# Make sure strings are *not* read in as factors
populations <- read.csv("data/uscitiesv1.4.csv", stringsAsFactors = FALSE)
# Load the `"data/uscitiesv1.4.csv` file into a variable `populations`
# Make sure strings are *not* read in as factors
populations <- read.csv("data/uscitiesv1.4.csv", stringsAsFactors = FALSE)
# Load the `"data/uscitiesv1.4.csv` file into a variable `populations`
# Make sure strings are *not* read in as factors
populations <- read.csv("data/uscitiesv1.4.csv", stringsAsFactors = FALSE)
# Because leaflet can only render a few thousand points, create a variable
# `most_populous` that has the 1000 cities with the largest populations
# (hint: use `top_n()`)
most_populaous <- top_n(populations, 1000)
# To create a base layer map (that has access to your data), create a variable
# `map` by passing your `most_populous` data to the `leaflet()` function and
# then adding a layer of map tiles (via a pipe %>% ) by calling the
# `add_tiles()` function. This will create a blank map.
map <- leaflet(data = most_populaous) %>%
add_tiles()
# To create a base layer map (that has access to your data), create a variable
# `map` by passing your `most_populous` data to the `leaflet()` function and
# then adding a layer of map tiles (via a pipe %>% ) by calling the
# `add_tiles()` function. This will create a blank map.
map <- leaflet(data = most_populaous) %>%
addTiles()
map
# To add a layer of circles to your map, pipe your `map` variable to the
# `addCircleMarkers` function, specifying the following:
# - The latitude (`lat`) as the variable `lat` (as a formula)
# - The longitude (`lng`) as the variable `lng` (as a formula)
# - The pop-up text (`popup`) as the variable `city` (as a formula)
# - The outline of each circle (`stroke`) should be `FALSE`
# - The `radius` should be 1, and the `fillOpacity` should be .5
map <- leaflet(data = most_populaous) %>%
addTiles() %>%
addCircleMarkers(lat = lat, lng = lng, popup = city, stroke = FALSE, radius = 1, fillOpacity = .5)
View(most_populaous)
# To add a layer of circles to your map, pipe your `map` variable to the
# `addCircleMarkers` function, specifying the following:
# - The latitude (`lat`) as the variable `lat` (as a formula)
# - The longitude (`lng`) as the variable `lng` (as a formula)
# - The pop-up text (`popup`) as the variable `city` (as a formula)
# - The outline of each circle (`stroke`) should be `FALSE`
# - The `radius` should be 1, and the `fillOpacity` should be .5
map <- leaflet(data = most_populaous) %>%
addTiles() %>%
addCircleMarkers(lat = ~lat, lng = ~lng, popup = ~city, stroke = FALSE, radius = 1, fillOpacity = .5)
map
# If you want each city to be sized proportionally to the population,
# you have to compute the desired number of pixels for each marker. Create a
# new column `radius` that is the population relative to the maximum population
# times a constant number of pixels (e.g., 3). If you want the *area* to be
# proportional to the data, you should *square* this value.
most_populaous$radius <- (most_populaous$population / max(most_populaous$population)) * 300
map
# Remake the map from above, specifying the `radius` column as the radius
map <- leaflet(data = most_populaous) %>%
addTiles() %>%
addCircleMarkers(lat = ~lat, lng = ~lng, popup = ~city, stroke = FALSE, radius = ~radius, fillOpacity = .5)
map
# Remake the map from above, specifying the `radius` column as the radius
map <- leaflet(data = most_populaous) %>%
addTiles() %>%
addCircleMarkers(lat = ~lat, lng = ~lng, popup = ~city, stroke = FALSE, radius = ~radius * 100, fillOpacity = .5)
map
# Remake the map from above, specifying the `radius` column as the radius
map <- leaflet(data = most_populaous) %>%
addTiles() %>%
addCircleMarkers(lat = ~lat, lng = ~lng, popup = ~city, stroke = FALSE, radius = ~radius * 100000, fillOpacity = .5)
map
setwd("~/Documents/infoGit/INFO201_group_project-")
happyness_data <- read.csv("data/happiness/2018.csv", stringsAsFactors = FALSE)
co2_data <- read.csv("data/owid-co2-data.csv", stringsAsFactors = FALSE)
View(happyness_data)
View(happyness_data)
View(co2_data)
# This document creates a data frame of summerised data that we will
# use in our project.
library(dplyr)
# filtering co2_data to contain only information we need
edit_co2_data <- co2_data %>%
filter(year == 2018)
View(edit_co2_data)
# filtering co2_data to contain only information we need
edit_co2_data <- co2_data %>%
filter(year == 2018, iso_code == TRUE)
# filtering co2_data to contain only information we need
edit_co2_data <- co2_data %>%
filter(year == 2018)
# filtering co2_data to contain only information we need
edit_co2_data <- co2_data %>%
filter(year == 2018) %>%
select(country, co2, cumulative_co2, population)
# filtering co2_data to contain only information we need
edit_co2_data <- co2_data %>%
filter(year == 2018) %>%
select(country, co2, cumulative_co2, population) %>%
rename(
country = Country.or.region
)
# filtering co2_data to contain only information we need
edit_co2_data <- co2_data %>%
filter(year == 2018) %>%
select(country, co2, cumulative_co2, population) %>%
rename(Country.or.region = country)
# Joining edit_co2_data and happyness_data by country (inner join)
final_data <- inner_join(happyness_data, edit_co2_data, by = 'Country.or.region')
View(final_data)
# Saving final_data to data folder for this project
write.csv(final_data, "data/final_data.csv", row.names = FALSE)
>>>>>>> 8ae1f16189a42068b5cc848a57257d1ac64a667f
